/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * RiskStartGame.java
 *
 * Created on Nov 15, 2010, 11:13:31 AM
 */

package Risk.Controller;

import java.awt.ComponentOrientation;
import java.awt.Container;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;

import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.MidiSystem;
import javax.sound.midi.MidiUnavailableException;
import javax.sound.midi.Sequence;
import javax.sound.midi.Sequencer;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.ScrollPaneConstants;

/**
 *
 * @author cube
 */
public class RiskStartGameController extends java.awt.Frame {
	/** Creates new form RiskStartGame */

	public RiskStartGameController() {
		initComponents();
		jButton1.setEnabled(false);
		setLocationRelativeTo(null);

		try {
			Sequence song = MidiSystem.getSequence(getClass().getResourceAsStream("../resources/song.mid"));
			Sequencer sequencer = MidiSystem.getSequencer();
			sequencer.open();

			sequencer.setSequence(song);
			sequencer.setLoopCount(2);
			// sequencer.start();

		} catch (IOException e) {
		} catch (MidiUnavailableException e) {
		} catch (InvalidMidiDataException e) {
		}
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initComponents() {
		jPanel1 = new javax.swing.JPanel();
		jButton1 = new javax.swing.JButton();
		jButton3 = new javax.swing.JButton();
		jButton2 = new javax.swing.JButton();
		jLabel1 = new javax.swing.JLabel();

		setBackground(new java.awt.Color(1, 1, 1));
		addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent evt) {
				exitForm(evt);
			}
		});

		jPanel1.setBackground(new java.awt.Color(1, 1, 1));
		jPanel1.setName("jPanel1"); // NOI18N

		jButton1.setText("Start Game");
		jButton1.setName("jButton1"); // NOI18N
		jButton1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				jButton1ActionPerformed(evt);
			}
		});

		jButton3.setText("Exit");
		jButton3.setName("jButton3"); // NOI18N
		jButton3.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				jButton3ActionPerformed(evt);
			}
		});

		jButton2.setText("Add RiskPlayer");
		jButton2.setName("jButton2"); // NOI18N
		jButton2.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				jButton2ActionPerformed(evt);
			}
		});

		jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("../resources/risk-logo.jpg"))); // NOI18N
		jLabel1.setName("jLabel1");

		JButton btnChooseMap = new JButton();
		btnChooseMap.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				try {
					generateChooseMapPanel();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}

		});
		btnChooseMap.setText("Choose Map");
		btnChooseMap.setName("jButton1");
		btnChooseMap.setEnabled(true);

		javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
		jPanel1Layout.setHorizontalGroup(jPanel1Layout.createParallelGroup(Alignment.TRAILING)
				.addGroup(jPanel1Layout.createSequentialGroup().addContainerGap()
						.addGroup(jPanel1Layout.createParallelGroup(Alignment.LEADING)
								.addGroup(jPanel1Layout.createSequentialGroup().addComponent(jLabel1)
										.addContainerGap(43, Short.MAX_VALUE))
								.addGroup(jPanel1Layout.createSequentialGroup().addGap(109)
										.addGroup(jPanel1Layout.createParallelGroup(Alignment.CENTER)
												.addComponent(jButton2, GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)
												.addComponent(jButton3, GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE)
												.addComponent(btnChooseMap, GroupLayout.PREFERRED_SIZE, 113,
														GroupLayout.PREFERRED_SIZE)
												.addComponent(jButton1, GroupLayout.DEFAULT_SIZE, 121, Short.MAX_VALUE))
										.addGap(87)))));
		jPanel1Layout.setVerticalGroup(jPanel1Layout.createParallelGroup(Alignment.LEADING)
				.addGroup(jPanel1Layout.createSequentialGroup().addContainerGap().addComponent(jLabel1)
						.addPreferredGap(ComponentPlacement.UNRELATED).addComponent(btnChooseMap).addGap(12)
						.addComponent(jButton1).addPreferredGap(ComponentPlacement.RELATED).addComponent(jButton2)
						.addPreferredGap(ComponentPlacement.UNRELATED).addComponent(jButton3)
						.addContainerGap(42, Short.MAX_VALUE)));
		jPanel1.setLayout(jPanel1Layout);

		add(jPanel1, java.awt.BorderLayout.CENTER);

		pack();
	}

	/** Exit the Application */
	private void exitForm(java.awt.event.WindowEvent evt) {
		System.exit(0);
	}

	private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {
		System.exit(0);
	}

	private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {
		RiskAddPlayerController add = new RiskAddPlayerController();
		add.setVisible(true);
	}

	/**
	 * Creates the JFrame and JPanels within on the click on Choose Map Button. Uses
	 * GridBagLayout for the components within.
	 * 
	 * @throws IOException
	 */
	private void generateChooseMapPanel() throws IOException {

		JFrame generateMapFrame = new JFrame("Generate Map");
		generateMapFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		generateMapFrame.setResizable(false);

		Container pane = generateMapFrame.getContentPane();
		pane.setLayout(new GridBagLayout());
		pane.setComponentOrientation(ComponentOrientation.UNKNOWN);

		GridBagConstraints c = new GridBagConstraints();

		scrollTextAreaPanel = new JPanel();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 30;
		c.ipady = 400;
		c.gridx = 1;
		c.gridy = 0;
		mapEditTextArea = new JTextArea("", 200, 120);
		mapEditTextArea.setEditable(false);
		scrollTextAreaPanel.add(new JScrollPane(mapEditTextArea, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
				ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED));
		pane.add(scrollTextAreaPanel, c);

		JPanel inputLinePanel = new JPanel();
		mapEditTextField = new JTextField("", 120);
		inputLinePanel.add(mapEditTextField);
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1;
		c.gridx = 1;
		c.ipady = 50;
		c.gridy = 2;
		pane.add(inputLinePanel, c);

		JPanel buttonsPanel = new JPanel();
		JButton addButton = new JButton("Add");
		JButton finishButton = new JButton("Finish");

		/**
		 * Handles the click event for the add button in the Choose Map Panel.
		 */
		addButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				addButtonPressed(e);
			}
		});

		/**
		 * Handles the click event for the finish button in the Choose Map Panel.
		 */
		finishButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				finishButtonPressed(e);
			}

		});

		buttonsPanel.add(addButton);
		buttonsPanel.add(finishButton);
		c.weightx = 0.5;
		c.gridx = 1;
		c.ipady = 50;
		c.gridy = 3;
		pane.add(buttonsPanel, c);

		generateMapFrame.pack();
		generateMapFrame.setVisible(true);
	}

	private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {
		RiskController.ShowGUI();
		setVisible(false);
	}

	/**
	 * Performs final activities for creating and saving the newly created Map for
	 * the current game. Creating the file CurrentMap.map and initializes it till
	 * '[Territories]' from the earth map. Copies the contents of the JTextArea in
	 * Choose Map Panel and save the file in the Risk.resources package.
	 * 
	 * @param e,
	 *            Action event for the click of the Finish button.
	 */
	private void finishButtonPressed(ActionEvent e) {
		CurrentGameMapEditor("");
		CurrentGameMapEditor(mapEditTextArea.getText());
	}

	private void initializeMapVariables() {
		BufferedReader brEarthMapReader = new BufferedReader(new InputStreamReader(
				RiskStartGameController.class.getResourceAsStream("/Risk/resources/Earth_updated.map")));
		String baseMapLine;
		try {
			while ((baseMapLine = brEarthMapReader.readLine()) != null) {
				sbBaseMapString.append(baseMapLine + "\n");
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Creates a new instance of the CurrentMap.map file and initializes with text
	 * will '[Territories]' from the base earth map. Appends the contents of the
	 * JTextArea in Choose Map Panel to the newly created file
	 * 
	 * @param editTextArea,
	 *            content of the JTextArea in Choose Map Panel.
	 */
	private void CurrentGameMapEditor(String editTextArea) {
		String EarthMapStaticContent;
		BufferedWriter brCurrentMapModifier;
		File currentGameMap;

		try {
			currentGameMap = new File("src/Risk/resources/CurrentMap.map");
			brCurrentMapModifier = new BufferedWriter(new FileWriter(currentGameMap, true));

			// Called during initialize
			if (editTextArea.equals("")) {
				brCurrentMapModifier = new BufferedWriter(new FileWriter(currentGameMap, false));
				EarthMapStaticContent = sbBaseMapString.substring(0,
						sbBaseMapString.indexOf("[Territories]") + String.valueOf("[Territories]").length());
				brCurrentMapModifier.write(EarthMapStaticContent, 0, EarthMapStaticContent.length());
				brCurrentMapModifier.close();
			} else {
				brCurrentMapModifier = new BufferedWriter(new FileWriter(currentGameMap, true));
				brCurrentMapModifier.write("\n" + editTextArea, 0, editTextArea.length());
				brCurrentMapModifier.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Processes user input from the JTextField. Calls another method to fetch and
	 * insert coordinates for the territory. Appends the input with coordinates to
	 * the JTextArea in Choose Map Panel
	 * 
	 * @param e
	 *            ActionEvent passed for the button click event.
	 */
	private void addButtonPressed(ActionEvent e) {
		if (validateMapLineInputText(mapEditTextField.getText())) {
			mapEditTextArea.append(mapEditTextInsertCoordinates(mapEditTextField.getText()) + "\n");
			scrollTextAreaPanel.repaint();
			mapEditTextField.setText("");
		} else {
			// message user!
		}
	}

	/**
	 * To find the territory which the user supplied in his/her input text. To find
	 * the coordinates of the supplied territory from the baseMap - EarthMap. Append
	 * the found coordinates to the input text and insert them in the JTextArea in
	 * Choose Map Panel.
	 * 
	 * @param mapInputLineText,
	 *            input text inserted by the user specifying the territory and the
	 *            adjacent countries.
	 * @return String, the complete line text with the coordinates inserted after
	 *         the territory.
	 */
	private String mapEditTextInsertCoordinates(String mapInputLineText) {

		StringBuilder sbInputWithCoordinates = new StringBuilder();
		String territory = mapInputLineText.substring(0, mapInputLineText.indexOf(','));
		String coordinates = fetchCoordinates(territory);

		sbInputWithCoordinates.append(mapInputLineText.substring(0, mapInputLineText.indexOf(','))).append(coordinates)
				.append(mapInputLineText.substring(mapInputLineText.indexOf(',') + 1, mapInputLineText.length()));

		return sbInputWithCoordinates.toString();
	}

	/**
	 * Fetch the coordinates of the territories given to this method. Call the
	 * recursive search function to perform the search.
	 * 
	 * @param territory,
	 *            territory inserted by the user.
	 * @return = String, the coordinates of the territory supplied in string - e.g -
	 *         ,XX,YY, - format.
	 */
	private String fetchCoordinates(String territory) {
		String coordinates = "";
		initializeMapVariables();
		coordinates = recursiveSearchCoordinates(sbBaseMapString.toString(), territory);
		return coordinates;
	}

	/**
	 * The base earth map has individual territories specified in multiple places.
	 * At times as countries with coordinates next to it and at times as an adjacent
	 * country to some other country during which it does not have coordinates next
	 * to it. Hence a recursive search is needed to find only that particular
	 * instance of country which has coordinates next to it in the base map. This
	 * function performs that recursive search needed.
	 * 
	 * @param baseMapString,
	 *            this class level variable has the earth map read into it in string
	 *            format.
	 * @param territory,
	 *            this is the territory inserted by the user.
	 * @return coordinates, returns the coordinates of the needed territory in
	 *         string - ,XX/X,YY/Y, - format.
	 */
	private String recursiveSearchCoordinates(String baseMapString, String territory) {
		int index;
		index = baseMapString.indexOf(territory);
		int updatedindex;
		if (index != -1) {
			if (isCoordinatesNextToIt(baseMapString, index, territory)) {
				fetchedCoordinates = fetchCoordinates(index + territory.length(), baseMapString); // alaska-,27,29,-abc
																									// : pass char
																									// within colon.
				return fetchedCoordinates;
			} else {
				updatedindex = updateIndexToNextTerritory(baseMapString, territory, index);
				baseMapString = baseMapString.substring(updatedindex, baseMapString.length());
				recursiveSearchCoordinates(baseMapString, territory);
			}
		} else
			return fetchedCoordinates;
		return fetchedCoordinates;
	}

	/**
	 * The recursive search take a smaller text every iteration till the correct
	 * instance of territory is found. This method sends the begin index for the new
	 * cut-shorted string for the next recursive search.
	 * 
	 * @param baseMapString,
	 *            string for the entire base map.
	 * @param territory,
	 *            territory supplied by the user.
	 * @param index,
	 *            index of the first character of the incorrect territory instance.
	 * @return begin index, for the upcoming recursive search.
	 */
	private int updateIndexToNextTerritory(String baseMapString, String territory, int index) {
		if (baseMapString.charAt(index + territory.length()) == ','
				|| String.valueOf(baseMapString.charAt(index + territory.length())) == "")
			return index + territory.length() + 1;
		else
			return index + territory.length();
	}

	/**
	 * Once the correct instance of the word territory is found in the base earth
	 * map, this method will read the coordinates next to it.
	 * 
	 * @param index,
	 *            index of the correct instance of the territory in the base map.
	 * @param baseMapString,
	 *            the base map in string format.
	 * @return coordinates, in the format XX/X,YY/Y.
	 */
	private String fetchCoordinates(int index, String baseMapString) {
		// TODO Auto-generated method stub
		StringBuilder coordinates = new StringBuilder();
		for (char a : baseMapString.substring(index, baseMapString.length() - 1).toCharArray()) {
			if (!Character.isDigit(a)) {
				if (a != ',' && Character.toString(a) != "")
					break;
			}
			coordinates.append(a); // Like ,29,39,
		}
		return coordinates.toString();
	}

	/**
	 * Checks whether the instance of territory found in the base map has
	 * coordinates next to it or not.
	 * 
	 * @param baseMapString,
	 *            base earth map in string format.
	 * @param index,
	 *            index of the first occurrence 'territory' in the base map.
	 * @param territory,
	 *            the territory supplied by the user.
	 * @return Boolean, true if this is the instance of territory with coordinates
	 *         next to it else False.
	 */
	private boolean isCoordinatesNextToIt(String baseMapString, int index, String territory) {
		String subbaseMapString = baseMapString.substring(index);
		if (Character.isDigit(subbaseMapString.charAt(territory.length() + 1))) // Brazil,10,10,
			return true;
		else
			return false;
	}

	/**
	 * To check of the user has inserted the text in the proper format. Check if
	 * corresponding territories and continents exist.
	 * 
	 * @param mapInputLineText,
	 *            the input text from the user in the needed format specifying the
	 *            adjacent countries.
	 * @return Boolean, returns true if input text is valid, else false.
	 */
	private Boolean validateMapLineInputText(String mapInputLineText) {
		return true;
	}

	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void main(String args[]) {
		java.awt.EventQueue.invokeLater(new Runnable() {
			public void run() {
				new RiskStartGameController().setVisible(true);
			}
		});
	}

	public static javax.swing.JButton jButton1;
	private javax.swing.JButton jButton2;
	private javax.swing.JButton jButton3;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JTextArea mapEditTextArea;
	private javax.swing.JTextField mapEditTextField;
	private String fetchedCoordinates;
	private JPanel scrollTextAreaPanel;
	private StringBuilder sbBaseMapString = new StringBuilder();

}
